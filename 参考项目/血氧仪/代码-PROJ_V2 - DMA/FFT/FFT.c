#include "FFT.h"

//保存SIN值
signed char SIN_TAB[128]={																					
	0x00,  0x06,  0x0c,  0x12,  0x18,  0x1e,  0x24,  0x2a,
	0x30,  0x36,  0x3b,  0x41,  0x46,  0x4b,  0x50,  0x55,
	0x59,  0x5e,  0x62,  0x66,  0x69,  0x6c,  0x70,  0x72,
	0x75,  0x77,  0x79,  0x7b,  0x7c,  0x7d,  0x7e,  0x7e,
	0x7f,  0x7e,  0x7e,  0x7d,  0x7c,  0x7b,  0x79,  0x77,
	0x75,  0x72,  0x70,  0x6c,  0x69,  0x66,  0x62,  0x5e,
	0x59,  0x55,  0x50,  0x4b,  0x46,  0x41,  0x3b,  0x36,
	0x30,  0x2a,  0x24,  0x1e,  0x18,  0x12,  0x0c,  0x06,
	0x00,	-0x06, -0x0c, -0x12, -0x18, -0x1e, -0x24,	-0x2a,
 -0x30, -0x36, -0x3b, -0x41, -0x46, -0x4b, -0x50, -0x55,
 -0x59, -0x5e, -0x62, -0x66, -0x69, -0x6c, -0x70, -0x72,
 -0x75, -0x77, -0x79, -0x7b, -0x7c, -0x7d, -0x7e, -0x7e,
 -0x7f, -0x7e, -0x7e, -0x7d, -0x7c, -0x7b, -0x79, -0x77,
 -0x75, -0x72, -0x70, -0x6c, -0x69, -0x66, -0x62, -0x5e,
 -0x59, -0x55, -0x50, -0x4b, -0x46, -0x41, -0x3b, -0x36,
 -0x30, -0x2a, -0x24, -0x1e, -0x18, -0x12, -0x0c, -0x06};


//以下是放大128倍后的cos余弦函数数组表格，这里注意事项与上面相同，只不过选择余弦来生成
signed char COS_TAB[128]={
	0x7f,  0x7e,  0x7e,  0x7d,  0x7c,  0x7b,  0x79,  0x77,
	0x75,  0x72,  0x70,  0x6c,  0x69,  0x66,  0x62,  0x5e,
	0x59,  0x55,  0x50,  0x4b,  0x46,  0x41,  0x3b,  0x36,
	0x30,  0x2a,  0x24,  0x1e,  0x18,  0x12,  0x0c,  0x06,
	0x00, -0x06, -0x0c, -0x12, -0x18, -0x1e, -0x24, -0x2a,
 -0x30, -0x36, -0x3b, -0x41, -0x46, -0x4b, -0x50, -0x55,
 -0x59, -0x5e, -0x62, -0x66, -0x69, -0x6c, -0x70, -0x72,
 -0x75, -0x77, -0x79, -0x7b, -0x7c, -0x7d, -0x7e, -0x7e,
 -0x7f, -0x7e, -0x7e, -0x7d, -0x7c, -0x7b, -0x79, -0x77,
 -0x75, -0x72, -0x70, -0x6c, -0x69, -0x66, -0x62, -0x5e,
 -0x59, -0x55, -0x50, -0x4b, -0x46, -0x41, -0x3b, -0x36,
 -0x30, -0x2a, -0x24, -0x1e, -0x18, -0x12, -0x0c, -0x06,
	0x00,  0x06,  0x0c,  0x12,  0x18,  0x1e,  0x24,  0x2a,
	0x30,  0x36,  0x3b,  0x41,  0x46,  0x4b,  0x50,  0x55,
	0x59,  0x5e,  0x62,  0x66,  0x69,  0x6c,  0x70,  0x72,
	0x75,  0x77,  0x79,  0x7b,  0x7c,  0x7d,  0x7e,  0x7e};


unsigned char LIST_TAB[128]={
	0,64,32,96,16,80,48,112,
	8,72,40,104,24,88,56,120,
	4,68,36,100,20,84,52,116,
	12,76,44,108,28,92,60,124,
	2,66,34,98,18,82,50,114,
	10,74,42,106,26,90,58,122,
	6,70,38,102,22,86,54,118,
	14,78,46,110,30,94,62,126,
	1,65,33,97,17,81,49,113,
	9,73,41,105,25,89,57,121,
	5,69,37,101,21,85,53,117,
	13,77,45,109,29,93,61,125,
	3,67,35,99,19,83,51,115,
	11,75,43,107,27,91,59,123,
	7,71,39,103,23,87,55,119,
	15,79,47,111,31,95,63,127};


signed short Fft_Real[128]; 												//fft实部，128数组
signed short Fft_Image[128]; 												//fft虚部，128数组


void FFT(void)
{
	unsigned char	i,j,k,b,p;
	signed short Temp_Real,Temp_Imag,temp; 						//中间临时变量，名称也是自己定义的，但要与fft函数里面的对应
	//unsigned short TEMP1; 														//用于求功率的，可不需要
	unsigned char N=7; 																//这里因为128是2的7次方，如果是计算256点，则是2的8次方，N就是8，如果是512点则N＝9，如此类推
	unsigned short NUM_FFT=128; 											//这里要算多少点的fft就赋值多少，值只能是2的N次方

	for( i=1; i<=N; i++)             									/* for(1) */
	{
		b=1;
		b <<=(i-1);                 										//蝶式运算，用于计算 隔多少行计算。例如第一级 1和2行计算，，，第二级
		for( j=0; j<=b-1; j++)       										/* for (2) */
		{
			p=1;
			p <<= (N-i);            
			p = p*j;
			for( k=j; k<NUM_FFT; k=k+2*b)   							/* for (3) 基二fft */
			{
				Temp_Real = Fft_Real[k]; Temp_Imag = Fft_Image[k]; temp = Fft_Real[k+b];
				Fft_Real[k] = Fft_Real[k] + ((Fft_Real[k+b]*COS_TAB[p])>>7) + ((Fft_Image[k+b]*SIN_TAB[p])>>7);
				Fft_Image[k] = Fft_Image[k] - ((Fft_Real[k+b]*SIN_TAB[p])>>7) + ((Fft_Image[k+b]*COS_TAB[p])>>7);
				Fft_Real[k+b] = Temp_Real - ((Fft_Real[k+b]*COS_TAB[p])>>7) - ((Fft_Image[k+b]*SIN_TAB[p])>>7);
				Fft_Image[k+b] = Temp_Imag + ((temp*SIN_TAB[p])>>7) - ((Fft_Image[k+b]*COS_TAB[p])>>7);     
				//移位，防止溢出。结果已经是本值的1/64               
				Fft_Real[k] >>= 1;            
				Fft_Image[k] >>= 1;
				Fft_Real[k+b]  >>= 1;                 
				Fft_Image[k+b]  >>= 1;
			}     
		}
	}
//Fft_Real[0]=Fft_Image[0]=0;  //去掉直流分量，也可以不去掉
//Fft_Real[63]=Fft_Image[63]=0;
/********以上已经把128点的实部和虚部求完，下一次运算前需要把所有虚部重新清零
要求某个频率点的模，则模值=根号(实部平方+虚部平方)，即sqrt((Fft_Real[n]*Fft_Real[n])+(Fft_Image[n]*Fft_Image[n]))
第n个频率点的值是数组上的Fft_Real[n]和Fft_Image[n]，而Fft_Real[0]是直流分量。Fft_Real[1]是最低频率点，也是最小频率分辩率值，
等于采样率/采样点数N，波形峰值大小=模值/(N/2)， N为采样点数。注意，由于上面把求得的值已经移位除法，相当于缩小了64倍
(移位7位好像是128倍吧？？后面为什么还要移动一位？这里待高手指点，本人也不是很清楚，这里只做移植总结)
得到的那些实部虚部的结果爱怎么处理怎么处理，可以做音频频谱强度显示啦什么的******************/
}


void Fft_Imagclear(void) 			//fft虚部清零函数，在运行FFT函数之前需要先运行这个
{
	unsigned char a;  					//注意这里如果是256点以上要改成u16，下面的a<128条件也要相应的修改
	for(a=0;a<128;a++)
  {
		Fft_Image[a]=0;
  }
}


signed short Get_fft_value(int n,int m)
{
	if(n==0) return Fft_Real[m];
	else return Fft_Image[m];
}


